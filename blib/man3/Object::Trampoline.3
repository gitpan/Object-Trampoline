.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Object::Trampoline 3"
.TH Object::Trampoline 3 "2005-11-21" "perl v5.8.7" "User Contributed Perl Documentation"
.SH "NAME"
Object::Trampoline \- delay object construction until
a method is actually dispatched, simplifies runtime definition
of handler classes.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    # the real class name is added to the normal constructor
\&    # and 'Object::Trampoline' used instead. the destination
\&    # class' constructor is called when object is actually 
\&    # used for something.
.Ve
.PP
.Vb 1
\&    my $dbh = Object::Trampoline->connect( 'DBI', $dsn, $user, $pass, $conf );
.Ve
.PP
.Vb 1
\&    my $sth = $dbh->prepare( 'select foo from bar' );
.Ve
.PP
.Vb 5
\&    # or specify the package and args from a config file
\&    # or via inherited data.
\&    #
\&    # the constructor lives in the destination class
\&    # and has nothing to do with Object::Trampoline.
.Ve
.PP
.Vb 1
\&    my %config = Config->read( $config_file_path );
.Ve
.PP
.Vb 2
\&    my ( $class, $const, $argz )
\&    = @config{ qw( class const args ) };
.Ve
.PP
.Vb 1
\&    my $handle = Object::Trampoline->$const( $class, $argz );
.Ve
.PP
.Vb 1
\&    # at this point ref $handle is 'Object::Trampoline::Bounce'.
.Ve
.PP
.Vb 1
\&    $handle->frobnicate( @stuff );
.Ve
.PP
.Vb 1
\&    # at this point ref $handle is $class
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
There are times when constructing an object is expensive
or has to be delayed \*(-- database handles in heavily forked
apache servers are one example.  This module creates
a \*(L"trampoline\*(R" object: when called it replaces the object
you have with the object you want. The module itself
consists only of two \s-1AUTOLOADS:\s0 one with captures the
constructor call, the other the first method call. The
first class blesses a closure which creates the necessary
object into the second class, which replces \f(CW$_\fR[0] with
a new object and re-dispatches the call into the proper
class.
.PP
Using an autoload as the constructor allows Object::Trampoline
to use whatever constructor name the \*(L"real\*(R" class uses
without having to pass it as another argument.
.Sh "Delayed construction"
.IX Subsection "Delayed construction"
Object::Trampoline uses whatever constructor the destination
class calls (e.g., 'connect' for \s-1DBI\s0) with the destination class
is passed as the first argument.
.PP
For example the normal \s-1DBI\s0 construcion:
.PP
.Vb 1
\&    my $dbh = DBI->connect( $dsn, $user, $pass, $conf );
.Ve
.PP
becomes:
.PP
.Vb 1
\&    my $dbh = Object::Trampoline->connect( 'DBI', $dsn, $user, $pass, $conf );
.Ve
.PP
eventually follwed by some use of the \f(CW$dbh:\fR
.PP
.Vb 1
\&    # at this point ref $dbh is "Object::Trampline::Bounce"
.Ve
.PP
.Vb 1
\&    my $sth = $dbh->prepare( 'select foo from bar' );
.Ve
.PP
.Vb 1
\&    # at this point ref $dbh is "DBI::db"
.Ve
.PP
This can be handy for error or other special event handlers
they are not always used \*(-- especially if they have to read
initialization files or make database/directory service 
connections to get their setup data.
.Sh "Runtime classes"
.IX Subsection "Runtime classes"
This can also be handy for specifying a handler class 
via config or command-line arguments since the final
class is passed as an argument. If various handler 
classes share a constructor name then the first argument
to Object::Trampoline can be determined at runtime:
.PP
.Vb 2
\&    my $mailclass = $cmdline->{ mailer } || 'SMTP::Simple';
\&    my $mailconst = $cmdline->{ constructor } || 'constructify';
.Ve
.PP
.Vb 1
\&    ...
.Ve
.PP
.Vb 1
\&    my $mailer = Object::Trampoline->$mailconst( $mailclass, @blah );
.Ve
.PP
.Vb 1
\&    ...
.Ve
.PP
.Vb 1
\&    # $mailclass construction is delayed up to this point.
.Ve
.PP
.Vb 1
\&    $mailer->send( %message );
.Ve
.PP
This is useful when the constructor arguments themselvese
are expensive to arrive at but the handler object must be 
defined in advance. This allows \f(CW$mailer\fR to be defined 
even if the constructor arguments are not available (or
the construced class require\-ed) yet.
.PP
Note that \f(CW$mailconst\fR has nothing to do with Object::Trampoline,
but must be accessble to a \f(CW$mailclass\fR object.
.Sh "Handle Catalogs"
.IX Subsection "Handle Catalogs"
There are times when centeralizing the construction of a
few standard handles into a single module seems helpful:
all of the configuration issues can be pushed into a single
place and anyone who uses the module can get access to some
set of standard resources. The obvious downside to this is
having to construct all of the objects.
.PP
Trampoline objects overcome this by not constructing anything
[expensive] until it is really kneaded. Thus, a single 
\&\*(L"channel catalog\*(R" can be pushed into a single module (or
small set of them). 
.PP
A hard-coded catalog might start out as:
.PP
.Vb 1
\&    package Our::Channel::Catalog;
.Ve
.PP
.Vb 1
\&    use Our::Cmdline::Handler;
.Ve
.PP
.Vb 6
\&    my %defaultz =
\&    (
\&        test_host => 'testify.mysubnet',
\&        test_user => 'ttocs',
\&        test_pass => 'regit',
\&        test_data => 'foo',
.Ve
.PP
.Vb 2
\&        ...
\&    );
.Ve
.PP
.Vb 1
\&    my $cmdline = Our::Cmdline::Handler->construct( %defaultz );
.Ve
.PP
.Vb 1
\&    ...
.Ve
.PP
.Vb 13
\&    my $handlz = 
\&    {
\&        test_db =>
\&        Object::Catalog->connect
\&        (
\&            DBI =>
\&            (
\&                'dbi:mysql:hostname=$cmdline->{test_host};database=$cmdline->{test_data}',
\&                $cmdline->{user},
\&                $cmdline->{pass},
\&                $db_config,
\&            ),
\&        ),
.Ve
.PP
.Vb 11
\&        prod_db =>
\&        Object::Catalog->connect
\&        (
\&            DBI =>
\&            (
\&                'dbi:mysql:hostname=$cmdline->{test_host};database=$cmdline->{test_data}',
\&                $cmdline->{user},
\&                $cmdline->{pass},
\&                $db_config,
\&            ),
\&        ),
.Ve
.PP
.Vb 11
\&        test_chat =>
\&        Object::Catalog->connect
\&        (
\&            'Foo::Bar::Chatter' =>
\&            (
\&                Host => $cmdline->{chat_host},
\&                User => $cmdline->{chat_user},
\&                Pass => $cmdline->{chat_pass},
\&                Port => $cmdline->{chat_port},
\&            ),
\&        ),
.Ve
.PP
.Vb 2
\&        test_ldap =>
\&        ...
.Ve
.PP
.Vb 1
\&    };
.Ve
.PP
.Vb 3
\&    sub import
\&    {
\&        use Symbol;
.Ve
.PP
.Vb 1
\&        my $caller = caller;
.Ve
.PP
.Vb 1
\&        my $ref = qualify_to_ref 'handlz', $caller;
.Ve
.PP
.Vb 2
\&        *$ref = $handlz;
\&    }
.Ve
.PP
At this point anyonen can use Our::Channel::Catalog
and have immeidate access to the standard handles
(which have their default values and list pushed into
the revision control system).
.PP
A more realistic use of this puts the construction
parameters into, say, \s-1LDAP\s0 (e.g., \s-1RH\s0 Directory) for
shared use. The module can then isolate all the 
configuration issues into one place. 
.PP
Combined with FindBin::libs and NEXT::init a group
can inherit the necessary channels into a local 
catalog that varies by project or module. One way
to handle this is a collection of default channel
modules that are collected together via use base 
and NEXT::init into project-specific blocks of 
handles. This gives projects the flexability to 
generate a stock set of available handles without
the overhead of fully instantiating them all for 
each piece of code that uses any of them.
.Sh "Debugging with restricted resources."
.IX Subsection "Debugging with restricted resources."
There are times when objects must bind ports, access
unique-login services, or otherwise compete from single\-
use resources. Trampoline objects can help here: by 
delaying the resource use until something is actually
done with the object they allow debugging of startup 
issues. Obviously at some point there may be a resource
collision, but at least this delays things until the
last possible time.
.SH "KNOWN BUGS"
.IX Header "KNOWN BUGS"
.IP "\(bu" 4
Not a bug, really, but if your constructor has side effects
(e.g., opening log files) then delaying the construction will
delay the side effects. Net result is that the side effects
may have to migrate into the import where feasable or you just
have to wait for the side effects to show up when the object
is really used.
.IP "\(bu" 4
Also not really a bug, but it is the caller's responsability
to actually \*(L"use\*(R" or \*(L"require\*(R" the destination class prior
to actually constructing the object. The simple cases could
be handled with a string eval, but then there isn't a good
way to determine if a require or use is the proper choice.
In the interest of simplicity I've left that to the caller.
.RS 4
.Sp
.RS 4
One way around this would be passing in a closure as the 
first argument instead of the class. This could be executed
as-is to get the object. If anyone has a strong opinion on
this please warn me.
.RE
.RE
.RS 4
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
Steven Lembark <lembark@wrkhors.com>
